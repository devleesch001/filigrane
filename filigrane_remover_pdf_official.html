<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé® Filigrane PDF Suppression libre - outil libre</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        h1 {
            color: #333;
            margin: 0;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #666;
        }

        .connection-icon {
            font-size: 24px;
        }

        .main-layout {
            display: flex;
            gap: 30px;
            margin-top: 20px;
        }

        .left-panel {
            flex: 1;
        }

        .right-panel {
            flex: 1;
            min-width: 500px;
        }

        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .upload-area:hover {
            border-color: #999;
        }

        .upload-area.dragover {
            border-color: #4CAF50;
            background-color: #f8fff8;
        }

        input[type="file"] {
            display: none;
        }

        .text-input {
            width: 100%;
            margin-bottom: 15px;
        }

        .text-input label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .text-input input[type="text"],
        .text-input select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .position-inputs {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .position-inputs>div {
            flex: 1;
        }

        .position-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .position-control button {
            width: 30px;
            height: 30px;
            padding: 0;
            margin: 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .position-control input {
            flex: 1;
            text-align: center;
        }

        .style-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .style-button {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f5f5f5;
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .style-button.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            margin-top: 10px;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .status.success {
            background-color: #dff0d8;
            color: #3c763d;
        }

        .status.error {
            background-color: #f2dede;
            color: #a94442;
        }

        .preview-container {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            position: relative;
        }

        .preview-controls {
            margin-bottom: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .canvas-container {
            position: relative;
            display: block;
            width: 100%;
            min-height: 400px;
            border: 1px solid #ccc;
            background-color: white;
            cursor: crosshair;
            text-align: center;
            box-sizing: border-box;
            overflow: auto;
            /* Allow scrolling as requested */
        }

        #previewCanvas {
            display: inline-block;
            /* Center with text-align */
            height: auto;
            max-width: none;
            /* Allow full size, let container scroll */
        }

        #textOverlay {
            position: absolute;
            color: red;
            font-family: Helvetica, Arial, sans-serif;
            pointer-events: none;
            white-space: nowrap;
            border: 1px dashed red;
            padding: 2px;
            background-color: rgba(255, 255, 255, 0.7);
            transform-origin: left top;
        }

        .preview-info {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }

        .help-text {
            background-color: #e8f5e9;
            border-left: 4px solid #4CAF50;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 0 4px 4px 0;
        }

        .info-button {
            background-color: #2196F3;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            text-align: center;
            line-height: 24px;
            cursor: pointer;
            float: right;
            margin-top: -5px;
        }

        .checkbox-input {
            margin-bottom: 15px;
        }

        .checkbox-input label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
        }

        .checkbox-input input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .welcome-info {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            line-height: 1.6;
        }

        .welcome-info h3 {
            margin-top: 0;
            color: #4CAF50;
        }

        .welcome-info ol {
            padding-left: 20px;
        }

        .welcome-info li {
            margin-bottom: 10px;
        }

        .security-note {
            background-color: #e8f5e9;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
            text-align: center;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
        }

        /* Custom Logs Styles - Preserved */
        .logs-container h3 {
            font-size: 16px;
            margin-bottom: 5px;
            color: #666;
        }

        .log-section {
            height: 150px;
            margin-bottom: 10px;
            background: #f9f9f9;
            padding: 5px;
            border: 1px solid #eee;
            border-radius: 4px;
        }

        .log-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
            max-height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85em;
        }

        .log-list li {
            padding: 2px 0;
            border-bottom: 1px solid #eee;
            word-break: break-all;
        }

        .log-error {
            color: red;
        }

        .log-info {
            color: blue;
        }

        .log-hex {
            color: green;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header-bar">
            <h1>üé® Filigrane PDF Suppression - outil libre</h1>
            <div class="connection-status">
                <span class="connection-icon">üì¥</span>
                <span>Hors-ligne (s√©curis√©)</span>
            </div>
        </div>

        <div class="main-layout">
            <div class="left-panel">
                <div class="upload-area" id="uploadArea" onclick="document.getElementById('pdfFile').click()">
                    <p>Cliquez ici ou glissez-d√©posez votre fichier PDF</p>
                    <input type="file" id="pdfFile" accept=".pdf">
                </div>

                <div class="text-input">
                    <label for="watermarkText">üëâ Texte en filigrane √† enlever :</label>
                    <input type="text" id="watermarkText" placeholder="Ex: Filigrane">
                </div>

                <div class="text-input">
                    <label>Mode de suppression :</label>
                    <div class="style-buttons" id="modeButtons">
                        <div class="style-button active" data-value="instruction">Texte uniquement</div>
                        <div class="style-button" data-value="object">Couche compl√®te (WIP)</div>
                    </div>
                    <input type="hidden" id="removalMode" value="instruction">
                </div>

                <div class="style-buttons">
                    <button id="analyzeBtn" style="background-color: #2196F3; margin-top:0;">Analyser</button>
                    <button id="resetBtn" style="background-color: #f44336; margin-top:0;">R√©initialiser</button>
                </div>
                <button id="removeWatermarkBtn" style="background-color: #4CAF50; margin-top:64px;">‚¨áÔ∏è Suprimer le filigrane sur toutes les pages </button>

                <div id="status" class="status" style="display:none;"></div>

                <div class="logs-container" style="margin-top: 30px;">
                    <h3>Status</h3>
                    <div class="log-section">
                        <ul id="logErrors" class="log-list"></ul>
                    </div>
                </div>
            </div>

            <div class="right-panel">
                <div class="preview-container" id="previewContainer">
                    <div class="preview-controls">
                        <label for="previewPage">Page √† visualiser :</label>
                        <select id="previewPage">
                            <option value="1">Page 1</option>
                        </select>
                        <button id="updatePreviewBtn" style="width: auto; margin: 0;">Actualiser</button>
                    </div>
                    <div class="canvas-container" id="canvasContainer">
                        <canvas id="pdfPreview"></canvas>
                    </div>
                    <div class="preview-info">
                        <p>Visualisation de la <strong>Page <span id="targetPage">1</span></strong> du PDF.</p>
                    </div>
                </div>

                <div class="welcome-info" style="margin-top: 20px;">
                    <h3>Info S√©curit√©</h3>
                    <p>Ce traitement s'effectue enti√®rement dans votre navigateur. Aucun fichier n'est envoy√© sur un
                        serveur.</p>
                </div>
            </div>
        </div>
    </div>
    <script defer>
        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('pdfFile');
            const canvas = document.getElementById('pdfPreview');
            const ctx = canvas.getContext('2d');
            const removeBtn = document.getElementById('removeWatermarkBtn');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const resetBtn = document.getElementById('resetBtn');
            const statusDiv = document.getElementById('status');
            const watermarkInput = document.getElementById('watermarkText');
            const previewPageSelect = document.getElementById('previewPage');
            const updatePreviewBtn = document.getElementById('updatePreviewBtn');
            const previewContainer = document.getElementById('previewContainer');
            const targetPageSpan = document.getElementById('targetPage');
            const pdfjsLib = window['pdfjs-dist/build/pdf'];

            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

            let currentFileArrayBuffer = null;

            function logToSidebar(type, message, isHtml = false) {
                let listId;
                let colorClass;

                switch (type) {
                    case 'error':
                    case 'status':
                        listId = 'logErrors';
                        colorClass = type === 'error' ? 'log-error' : 'log-info';
                        break;
                    case 'literal':
                        listId = 'logLiteral';
                        colorClass = 'log-info';
                        break;
                    case 'hex':
                        listId = 'logHex';
                        colorClass = 'log-hex';
                        break;
                    default:
                        return;
                }

                const ul = document.getElementById(listId);
                if (ul) {
                    const li = document.createElement('li');
                    li.className = colorClass;
                    if (isHtml) {
                        li.innerHTML = message;
                    } else {
                        li.textContent = message;
                    }
                    ul.appendChild(li);
                }
            }

            // Clear sidebar logs
            function clearSidebar() {
                ['logErrors', 'logLiteral', 'logHex'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.innerHTML = '';
                });
            }

            let currentRenderTask = null; // Track current render task to cancel if needed
            let currentPdfDoc = null; // To store loaded PDF document for page switching

            // Page Selector Event Listener
            if (previewPageSelect) {
                previewPageSelect.addEventListener('change', function () {
                    if (currentPdfDoc) {
                        const pageNum = parseInt(this.value);
                        if (targetPageSpan) targetPageSpan.textContent = pageNum;
                        loadAndDisplayPdf(null, pageNum);
                    }
                });
            }

            if (updatePreviewBtn) {
                updatePreviewBtn.addEventListener('click', function () {
                    if (currentPdfDoc && previewPageSelect) {
                        const pageNum = parseInt(previewPageSelect.value);
                        loadAndDisplayPdf(null, pageNum);
                        logToSidebar('status', `Aper√ßu actualis√© (Page ${pageNum})`);
                    }
                });
            }

            // Drag and Drop Logic
            const uploadArea = document.getElementById('uploadArea');

            if (uploadArea) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, preventDefaults, false);
                });

                function preventDefaults(e) {
                    e.preventDefault();
                    e.stopPropagation();
                }

                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, highlight, false);
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, unhighlight, false);
                });

                function highlight(e) {
                    uploadArea.classList.add('dragover');
                }

                function unhighlight(e) {
                    uploadArea.classList.remove('dragover');
                }

                uploadArea.addEventListener('drop', handleDrop, false);

                function handleDrop(e) {
                    const dt = e.dataTransfer;
                    const files = dt.files;
                    handleFiles(files);
                }
            }

            function handleFiles(files) {
                if (files.length > 0) {
                    fileInput.files = files; // Update file input (for consistency)
                    // Trigger change event manually or call handler
                    const event = new Event('change');
                    fileInput.dispatchEvent(event);
                }
            }

            fileInput.addEventListener('change', (e) => {
                clearSidebar(); // Clear previous logs
                const file = e.target.files[0];
                if (!file) return;

                if (file.type !== 'application/pdf') {
                    updateStatus('Erreur : Veuillez s√©lectionner un fichier PDF valide.', 'red');
                    logToSidebar('error', 'Fichier invalide s√©lectionn√©.');
                    return;
                }

                const fileReader = new FileReader();
                fileReader.onload = function () {
                    currentFileArrayBuffer = this.result.slice(0); // Clone the buffer

                    // Pass a CLONE to loadAndDisplayPdf to avoid detaching currentFileArrayBuffer
                    loadAndDisplayPdf(currentFileArrayBuffer.slice(0))
                        .then(() => {
                            updateStatus('PDF charg√© avec succ√®s. Aper√ßu g√©n√©r√©.', 'green');
                            logToSidebar('status', 'PDF charg√©: ' + file.name);
                        })
                        .catch(error => {
                            console.error('Error rendering PDF:', error);
                            updateStatus('Erreur lors du chargement du PDF.', 'red');
                            logToSidebar('error', 'Erreur chargement PDF: ' + error.message);
                        });
                };

                try {
                    fileReader.readAsArrayBuffer(file);
                } catch (error) {
                    console.error('Error reading file:', error);
                    updateStatus('Erreur lors de la lecture du fichier.', 'red');
                }
            });

            /**
             * Loads a PDF from an ArrayBuffer or Uint8Array and renders the first page.
             * Handles cancelling previous render tasks.
             */
            /**
             * Loads a PDF from data or uses existing doc, and renders specific page.
             */
            async function loadAndDisplayPdf(data, pageNumber = 1) {
                // Cancel previous render if it exists
                if (currentRenderTask) {
                    currentRenderTask.cancel();
                    currentRenderTask = null;
                }

                try {
                    // If data is provided, load new document
                    if (data) {
                        const loadingTask = pdfjsLib.getDocument(new Uint8Array(data));
                        currentPdfDoc = await loadingTask.promise;

                        // Update Page Selector UI (V1 Style)
                        if (previewPageSelect) {
                            previewPageSelect.innerHTML = '';
                            const numPages = currentPdfDoc.numPages;

                            for (let i = 1; i <= numPages; i++) {
                                const option = document.createElement('option');
                                option.value = i;
                                option.textContent = `Page ${i}`;
                                previewPageSelect.appendChild(option);
                            }
                        }

                        // Show preview container
                        if (previewContainer) previewContainer.style.display = 'block';
                    }

                    if (!currentPdfDoc) return;

                    // Update selector value if it doesn't match requested page (e.g. programmatic call)
                    if (previewPageSelect) {
                        previewPageSelect.value = pageNumber;
                    }
                    if (targetPageSpan) {
                        targetPageSpan.textContent = pageNumber;
                    }

                    const page = await currentPdfDoc.getPage(pageNumber);
                    const scale = 1.0;
                    const viewport = page.getViewport({ scale: scale });

                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    const renderContext = {
                        canvasContext: ctx,
                        viewport: viewport
                    };

                    currentRenderTask = page.render(renderContext);
                    await currentRenderTask.promise;

                } catch (err) {
                    if (err.name === 'RenderingCancelledException') {
                        return;
                    }
                    throw err;
                }
            }

            const removalModeSelect = document.getElementById('removalMode');

            // ... existing code ...

            removeBtn.addEventListener('click', () => {
                if (!currentFileArrayBuffer) {
                    updateStatus('Veuillez d\'abord s√©lectionner un fichier PDF.', 'red');
                    return;
                }

                const textToRemove = watermarkInput.value;
                if (!textToRemove) {
                    updateStatus('Veuillez entrer le texte du filigrane √† supprimer.', 'red');
                    return;
                }

                const mode = removalModeSelect.value;
                updateStatus('Traitement en cours... Veuillez patienter.', 'blue');
                logToSidebar('status', `D√©but du traitement (Mode: Download, Strategy: ${mode})...`);

                const { PDFDocument } = PDFLib;

                PDFDocument.load(currentFileArrayBuffer.slice(0))
                    .then(pdfDoc => removeWatermark(pdfDoc, textToRemove, mode))
                    .then(pdfDoc => {
                        pdfDoc.setTitle(`Document`);
                        pdfDoc.setSubject(`Document PDF`);
                        pdfDoc.setCreator('PDF');
                        pdfDoc.setProducer(`PDF`);

                        return pdfDoc;
                    })
                    .then(pdfDoc => pdfDoc.save())
                    .then(pdfBytes => {
                        downloadPdf(pdfBytes, 'filigrane_removed.pdf');
                        updateStatus('Succ√®s ! Filigrane supprim√©. T√©l√©chargement lanc√©.', 'green');
                        logToSidebar('status', 'Succ√®s: Filigrane supprim√©.');
                    })
                    .catch(e => {
                        if (e.message === 'No watermark found') {
                            updateStatus('Le texte sp√©cifi√© n\'a pas √©t√© trouv√©.', 'orange');
                            logToSidebar('status', 'Aucun texte trouv√© √† supprimer.');
                        } else {
                            console.error(e);
                            updateStatus('Erreur lors de la suppression du filigrane : ' + e.message, 'red');
                            logToSidebar('error', 'Erreur: ' + e.message);
                        }
                    });
            });

            function performAnalysis() {
                if (!currentFileArrayBuffer) {
                    updateStatus('Veuillez d\'abord s√©lectionner un fichier PDF.', 'red');
                    return;
                }

                const textToRemove = watermarkInput.value;
                if (!textToRemove) {
                    // Quietly return or show status if triggered by button. 
                    // For input typing, we might not want to error immediately if empty, but here consistent behavior is fine.
                    updateStatus('Veuillez entrer le texte du filigrane √† chercher/analyser.', 'red');
                    return;
                }

                const mode = removalModeSelect.value;
                updateStatus('Analyse et pr√©visualisation en cours...', 'blue');
                logToSidebar('status', `Analyse en cours (Mode: Preview, Strategy: ${mode})...`);

                const { PDFDocument } = PDFLib;

                PDFDocument.load(currentFileArrayBuffer.slice(0))
                    .then(pdfDoc => removeWatermark(pdfDoc, textToRemove, mode))
                    .then(pdfDoc => pdfDoc.save())
                    .then(pdfBytes => {
                        updateStatus('Analyse termin√©e. Filigrane supprim√© dans la pr√©visualisation.', 'green');
                        logToSidebar('status', 'Succ√®s: Aper√ßu mis √† jour.');
                        const currentPage = previewPageSelect && previewPageSelect.value ? parseInt(previewPageSelect.value) : 1;
                        return loadAndDisplayPdf(pdfBytes, currentPage);
                    })
                    .catch(e => {
                        if (e.message === 'No watermark found') {
                            updateStatus('Le texte sp√©cifi√© n\'a pas √©t√© trouv√©.', 'orange');
                            logToSidebar('status', 'Aucun texte trouv√© √† supprimer.');
                            // Optionally reload original if analysis fails? Keeping current state might be safer/smoother.
                        } else {
                            console.error(e);
                            updateStatus('Erreur lors de l\'analyse : ' + e.message, 'red');
                            logToSidebar('error', 'Erreur: ' + e.message);
                        }
                    });
            }

            analyzeBtn.addEventListener('click', performAnalysis);

            // Debounce function
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // Debounced input listener (500ms)
            watermarkInput.addEventListener('input', debounce(() => {
                if (currentFileArrayBuffer && watermarkInput.value) {
                    performAnalysis();
                }
            }, 500));

            resetBtn.addEventListener('click', () => {
                if (!currentFileArrayBuffer) {
                    updateStatus('Aucun fichier charg√©.', 'red');
                    return;
                }

                loadAndDisplayPdf(currentFileArrayBuffer.slice(0))
                    .then(() => {
                        updateStatus('Vue r√©initialis√©e sur le fichier original.', 'green');
                        logToSidebar('status', 'Pr√©visualisation r√©initialis√©e (Original).');
                    })
                    .catch(e => {
                        console.error('Error resetting preview:', e);
                        logToSidebar('error', 'Erreur reset: ' + e.message);
                    });
            });

            function updateStatus(text, color) {
                statusDiv.textContent = text;
                statusDiv.style.color = color;
            }

            /**
             * Async function to remove watermark from a loaded PDFDocument.
             * Returns a Promise that resolves with the modified PDFDoc, or rejects if not found.
             * @param {PDFDocument} pdfDoc - The loaded pdf-lib document.
             * @param {string} textToRemove - The text pattern to remove.
             * @returns {Promise<PDFDocument>}
             */
            async function removeWatermark(pdfDoc, textToRemove) {
                const { PDFRawStream, PDFName } = PDFLib;

                const escapedText = textToRemove.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // Simple regex to check existence of text in content
                const pattern = new RegExp(`\\(${escapedText}\\)`, 'g');
                const hexText = encodeHex(textToRemove);
                const hexPattern = new RegExp(`<${hexText}>`, 'gi');

                const objects = pdfDoc.context.enumerateIndirectObjects();
                let modifiedCount = 0;
                const objectsToDelete = [];

                for (const [ref, obj] of objects) {
                    // We are looking for streams (where content is stored)
                    if (obj instanceof PDFRawStream) {
                        let contentBytes = obj.contents;
                        let isCompressed = false;

                        // Check for compression (Filter: /FlateDecode)
                        const filter = obj.dict.get(PDFName.of('Filter'));
                        if (filter === PDFName.of('FlateDecode')) {
                            try {
                                contentBytes = pako.inflate(contentBytes);
                                isCompressed = true;
                            } catch (e) {
                                console.warn(`Failed to decompress stream ${ref}`, e);
                                logToSidebar('error', `Erreur d√©compression stream ${ref}: ${e.message}`);
                                continue;
                            }
                        }

                        let contentString = "";
                        for (let i = 0; i < contentBytes.length; i++) {
                            contentString += String.fromCharCode(contentBytes[i]);
                        }

                        let objectContainsWatermark = false;

                        // 1. Literal Pattern
                        if (contentString.match(pattern)) {
                            logToSidebar('status', `Objet ${ref} contient le texte (Literal). Marquage pour suppression.`);
                            objectContainsWatermark = true;
                        }

                        // 2. Hex Pattern
                        if (contentString.match(hexPattern)) {
                            logToSidebar('status', `Objet ${ref} contient le texte (Hex). Marquage pour suppression.`);
                            objectContainsWatermark = true;
                        }

                        if (objectContainsWatermark) {
                            objectsToDelete.push(ref);
                            modifiedCount++;
                        }
                    }
                }

                // CLEANUP REFERENCES IN PAGES
                const pages = pdfDoc.getPages();
                for (let i = 0; i < pages.length; i++) {
                    const page = pages[i];
                    const { Contents } = page.node.normalizedEntries();

                    if (!Contents) continue;

                    // Handle Array of Content Streams
                    if (Contents instanceof PDFLib.PDFArray) {
                        for (let j = Contents.size() - 1; j >= 0; j--) {
                            const ref = Contents.get(j);
                            if (objectsToDelete.includes(ref)) {
                                Contents.remove(j);
                                logToSidebar('status', `Reference to ${ref} removed from Page ${i + 1}`);
                            }
                        }
                    }
                    // Handle Single Content Stream Reference
                    else if (Contents instanceof PDFLib.PDFRef) {
                        if (objectsToDelete.includes(Contents)) {
                            // Start thinking about how to handle this. 
                            // If the ONLY content stream is deleted, we might need a workaround or set to empty array.
                            // For now, let's try setting it to null or removing the entry if possible, 
                            // but pdf-lib might prefer an empty array.
                            // A safe bet is to replace with an empty array.
                            page.node.set(PDFName.of('Contents'), pdfDoc.context.obj([]));
                            logToSidebar('status', `Reference to ${Contents} replaced with empty array on Page ${i + 1}`);
                        }
                    }
                }

                // Delete marked objects
                for (const ref of objectsToDelete) {
                    pdfDoc.context.delete(ref);
                    logToSidebar('status', `Objet ${ref} supprim√© du contexte.`);
                }

                if (modifiedCount > 0) {
                    return pdfDoc;
                } else {
                    throw new Error('No watermark found');
                }
            }

            function downloadPdf(data, filename) {
                const blob = new Blob([data], { type: 'application/pdf' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }



            function decodeHex(hex) {
                try {
                    let str = '';
                    for (let k = 0; k < hex.length; k += 2) {
                        str += String.fromCharCode(parseInt(hex.substr(k, 2), 16));
                    }
                    return str;
                } catch (e) { return '(invalid hex)'; }
            }

            function encodeHex(str) {
                let hex = '';
                for (let i = 0; i < str.length; i++) {
                    hex += str.charCodeAt(i).toString(16).toUpperCase();
                }
                return hex;
            }
            // Mode Selection Logic
            const modeButtons = document.querySelectorAll('#modeButtons .style-button');
            const hiddenModeInput = document.getElementById('removalMode');

            if (modeButtons && hiddenModeInput) {
                modeButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        // Remove active class from all
                        modeButtons.forEach(b => b.classList.remove('active'));
                        // Add active to clicked
                        btn.classList.add('active');
                        // Update hidden input
                        hiddenModeInput.value = btn.dataset.value;
                    });
                });
            }
        });
    </script>
</body>

</html>